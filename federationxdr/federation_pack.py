# Generated by xdrgen.py from ../xdr/federation.x on Sat Feb 17 16:20:32 2018
from . import federation_const as const
from . import federation_type as types
import xdrlib
from xdrlib import Error as XDRError

class nullclass(object):
    pass

class federationPacker(xdrlib.Packer):
    def __init__(self, check_enum=True, check_array=True):
        xdrlib.Packer.__init__(self)
        self.check_enum = check_enum
        self.check_array = check_array

    pack_int = xdrlib.Packer.pack_int
    pack_uint = xdrlib.Packer.pack_uint
    pack_unsigned = xdrlib.Packer.pack_uint
    pack_hyper = xdrlib.Packer.pack_hyper
    pack_uhyper = xdrlib.Packer.pack_uhyper
    pack_float = xdrlib.Packer.pack_float
    pack_double = xdrlib.Packer.pack_double
    pack_quadruple = xdrlib.Packer.pack_double
    pack_bool = xdrlib.Packer.pack_bool
    pack_opaque = xdrlib.Packer.pack_opaque
    pack_string = xdrlib.Packer.pack_string
    def pack_CryptoKeyType(self, data):
        if hasattr(self, 'filter_CryptoKeyType'):
            data = getattr(self, 'filter_CryptoKeyType')(data)
        if self.check_enum and data not in [const.KEY_TYPE_ED25519, const.KEY_TYPE_HASH_TX, const.KEY_TYPE_HASH_X]:
            raise XDRError('value=%s not in enum CryptoKeyType' % data)
        self.pack_int(data)

    def pack_PublicKeyType(self, data):
        if hasattr(self, 'filter_PublicKeyType'):
            data = getattr(self, 'filter_PublicKeyType')(data)
        if self.check_enum and data not in [const.PUBLIC_KEY_TYPE_ED25519]:
            raise XDRError('value=%s not in enum PublicKeyType' % data)
        self.pack_int(data)

    def pack_uint256(self, data):
        if hasattr(self, 'filter_uint256'):
            data = getattr(self, 'filter_uint256')(data)
        self.pack_fopaque(32, data)

    def pack_PublicKey(self, data):
        if hasattr(self, 'filter_PublicKey'):
            data = getattr(self, 'filter_PublicKey')(data)
        if data.type is None:
            raise TypeError('data.type == None')
        self.pack_PublicKeyType(data.type)
        if data.type == const.PUBLIC_KEY_TYPE_ED25519:
            if data.ed25519 is None:
                raise TypeError('data.ed25519 == None')
            self.pack_uint256(data.ed25519)
        else:
            raise XDRError('bad switch=%s' % data.type)

    pack_AccountID = pack_PublicKey

    def pack_MemoType(self, data):
        if hasattr(self, 'filter_MemoType'):
            data = getattr(self, 'filter_MemoType')(data)
        if self.check_enum and data not in [const.MEMO_NONE, const.MEMO_TEXT, const.MEMO_ID, const.MEMO_HASH, const.MEMO_RETURN]:
            raise XDRError('value=%s not in enum MemoType' % data)
        self.pack_int(data)

    def pack_string64(self, data):
        if hasattr(self, 'filter_string64'):
            data = getattr(self, 'filter_string64')(data)
        if len(data) > 64 and self.check_array:
            raise XDRError('array length too long for data')
        self.pack_string(data)

    pack_uint64 = pack_uhyper

    def pack_Hash(self, data):
        if hasattr(self, 'filter_Hash'):
            data = getattr(self, 'filter_Hash')(data)
        self.pack_fopaque(32, data)

    def pack_Memo(self, data):
        if hasattr(self, 'filter_Memo'):
            data = getattr(self, 'filter_Memo')(data)
        if data.type is None:
            raise TypeError('data.type == None')
        self.pack_MemoType(data.type)
        if data.type == const.MEMO_NONE:
            pass
        elif data.type == const.MEMO_TEXT:
            if data.text is None:
                raise TypeError('data.text == None')
            if len(data.text) > 28 and self.check_array:
                raise XDRError('array length too long for data.text')
            self.pack_string(data.text)
        elif data.type == const.MEMO_ID:
            if data.id is None:
                raise TypeError('data.id == None')
            self.pack_uint64(data.id)
        elif data.type == const.MEMO_HASH:
            if data.hash is None:
                raise TypeError('data.hash == None')
            self.pack_Hash(data.hash)
        elif data.type == const.MEMO_RETURN:
            if data.retHash is None:
                raise TypeError('data.retHash == None')
            self.pack_Hash(data.retHash)
        else:
            raise XDRError('bad switch=%s' % data.type)

    def pack_FederationResponse(self, data):
        if hasattr(self, 'filter_FederationResponse'):
            data = getattr(self, 'filter_FederationResponse')(data)
        if data.stellarAddress is None:
            raise TypeError('data.stellarAddress == None')
        self.pack_string64(data.stellarAddress)
        if data.accountID is None:
            raise TypeError('data.accountID == None')
        self.pack_AccountID(data.accountID)
        if data.memo is None:
            raise TypeError('data.memo == None')
        self.pack_Memo(data.memo)
        if data.ext is None:
            raise TypeError('data.ext == None')
        if data.ext.v is None:
            raise TypeError('data.ext.v == None')
        self.pack_int(data.ext.v)
        if data.ext.v == 0:
            pass
        else:
            raise XDRError('bad switch=%s' % data.ext.v)

class federationUnpacker(xdrlib.Unpacker):
    def __init__(self, data, check_enum=True, check_array=True):
        xdrlib.Unpacker.__init__(self, data)
        self.check_enum = check_enum
        self.check_array = check_array

    unpack_int = xdrlib.Unpacker.unpack_int
    unpack_uint = xdrlib.Unpacker.unpack_uint
    unpack_unsigned = xdrlib.Unpacker.unpack_uint
    unpack_hyper = xdrlib.Unpacker.unpack_hyper
    unpack_uhyper = xdrlib.Unpacker.unpack_uhyper
    unpack_float = xdrlib.Unpacker.unpack_float
    unpack_double = xdrlib.Unpacker.unpack_double
    unpack_quadruple = xdrlib.Unpacker.unpack_double
    unpack_bool = xdrlib.Unpacker.unpack_bool
    unpack_opaque = xdrlib.Unpacker.unpack_opaque
    unpack_string = xdrlib.Unpacker.unpack_string
    def unpack_CryptoKeyType(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.KEY_TYPE_ED25519, const.KEY_TYPE_HASH_TX, const.KEY_TYPE_HASH_X]:
            raise XDRError('value=%s not in enum CryptoKeyType' % data)
        if hasattr(self, 'filter_CryptoKeyType'):
            data = getattr(self, 'filter_CryptoKeyType')(data)
        return data

    def unpack_PublicKeyType(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.PUBLIC_KEY_TYPE_ED25519]:
            raise XDRError('value=%s not in enum PublicKeyType' % data)
        if hasattr(self, 'filter_PublicKeyType'):
            data = getattr(self, 'filter_PublicKeyType')(data)
        return data

    def unpack_uint256(self):
        data = self.unpack_fopaque(32)
        if hasattr(self, 'filter_uint256'):
            data = getattr(self, 'filter_uint256')(data)
        return data

    def unpack_PublicKey(self):
        data = types.PublicKey()
        data.type = self.unpack_PublicKeyType()
        if data.type == const.PUBLIC_KEY_TYPE_ED25519:
            data.ed25519 = self.unpack_uint256()
        else:
            raise XDRError('bad switch=%s' % data.type)
        if hasattr(self, 'filter_PublicKey'):
            data = getattr(self, 'filter_PublicKey')(data)
        return data

    unpack_AccountID = unpack_PublicKey

    def unpack_MemoType(self):
        data = self.unpack_int()
        if self.check_enum and data not in [const.MEMO_NONE, const.MEMO_TEXT, const.MEMO_ID, const.MEMO_HASH, const.MEMO_RETURN]:
            raise XDRError('value=%s not in enum MemoType' % data)
        if hasattr(self, 'filter_MemoType'):
            data = getattr(self, 'filter_MemoType')(data)
        return data

    def unpack_string64(self):
        data = self.unpack_string()
        if len(data) > 64 and self.check_array:
            raise XDRError('array length too long for data')
        if hasattr(self, 'filter_string64'):
            data = getattr(self, 'filter_string64')(data)
        return data

    unpack_uint64 = unpack_uhyper

    def unpack_Hash(self):
        data = self.unpack_fopaque(32)
        if hasattr(self, 'filter_Hash'):
            data = getattr(self, 'filter_Hash')(data)
        return data

    def unpack_Memo(self):
        data = types.Memo()
        data.type = self.unpack_MemoType()
        if data.type == const.MEMO_NONE:
            pass
        elif data.type == const.MEMO_TEXT:
            data.text = self.unpack_string()
            if len(data.text) > 28 and self.check_array:
                raise XDRError('array length too long for data.text')
        elif data.type == const.MEMO_ID:
            data.id = self.unpack_uint64()
        elif data.type == const.MEMO_HASH:
            data.hash = self.unpack_Hash()
        elif data.type == const.MEMO_RETURN:
            data.retHash = self.unpack_Hash()
        else:
            raise XDRError('bad switch=%s' % data.type)
        if hasattr(self, 'filter_Memo'):
            data = getattr(self, 'filter_Memo')(data)
        return data

    def unpack_FederationResponse(self):
        data = types.FederationResponse()
        data.stellarAddress = self.unpack_string64()
        data.accountID = self.unpack_AccountID()
        data.memo = self.unpack_Memo()
        data.ext = nullclass()
        data.ext.v = self.unpack_int()
        if data.ext.v == 0:
            pass
        else:
            raise XDRError('bad switch=%s' % data.ext.v)
        if hasattr(self, 'filter_FederationResponse'):
            data = getattr(self, 'filter_FederationResponse')(data)
        return data

